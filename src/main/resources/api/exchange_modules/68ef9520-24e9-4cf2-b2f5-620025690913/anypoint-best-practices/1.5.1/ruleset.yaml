#%Validation Profile 1.0
profile: Anypoint Best Practices
description: This ruleset contains over 30 best practices for APIs to be used,
  maintained, and consumed across Anypoint Platform and beyond.
tags:
  - best-practices
violation:
  - api-must-have-title
  - base-url-pattern-server
  - camel-case-fields
  - define-path-params
  - define-path-template-variables
  - duplicated-entry-in-enum
  - media-type-headers-response
  - no-2xx-response
  - no-eval-in-markdown
  - no-script-tags-in-markdown
  - operations-must-have-identifiers
  - path-declarations-must-exist
  - path-not-include-query
  - provide-examples
  - resource-use-lowercase
  - use-schemas-requests
  - use-schemas-responses
warning:
  - api-must-have-description
  - api-must-have-documentation
  - date-only-representation
  - date-time-representation
  - headers-must-have-descriptions
  - heterogeneous-union
  - nil-union-antipattern
  - node-shapes-must-have-descriptions
  - non-scalar-url-parameters
  - not-anonymous-types
  - open-schemas-ignored
  - operations-must-have-descriptions
  - path-keys-no-trailing-slash
  - preferred-media-type-representations
  - property-shape-ranges-must-have-descriptions
  - query-params-must-have-descriptions
  - request-response-antipattern
  - responses-must-have-descriptions
  - standard-delete-status-codes
  - standard-get-status-codes
  - standard-post-status-codes
  - standard-put-status-codes
  - unsupported-response-schema-shapes
validations:
  api-must-have-description:
    message: Provide the description for the API.
    targetClass: apiContract.WebAPI
    propertyConstraints:
      core.description:
        minCount: 1
  api-must-have-documentation:
    message: Provide the documentation for the API.
    targetClass: apiContract.WebAPI
    propertyConstraints:
      core.documentation:
        minCount: 1
  api-must-have-title:
    message: Provide the title for the API.
    targetClass: apiContract.WebAPI
    propertyConstraints:
      core.name:
        minCount: 1
  base-url-pattern-server:
    message: Include “api” and the version of the API in the base URL. For example,
      `domain/api/v1`.
    targetClass: apiContract.Server
    or:
      - propertyConstraints:
          core.urlTemplate:
            pattern: /api/v[0-9]+
      - propertyConstraints:
          core.urlTemplate:
            pattern: /api/[0-9].[0.9]
  camel-case-fields:
    message: Use camelCase for all of the field names. Avoid underscores.
    targetClass: shacl.PropertyShape
    propertyConstraints:
      shacl.name:
        pattern: ^[a-z]+[1-9]?([A-Z][a-z1-9]+)*$
  date-only-representation:
    message: |
      Use standard date formats: ISO8601 Use calendar date:
        2016-10-27
    targetClass: shapes.ScalarShape
    if:
      and:
        - propertyConstraints:
            shacl.name:
              pattern: (^[dD]ate(((\-|\_)|[A-Z]).*)?$|.*((\-|\_)d|[D])ate(((\-|\_)|[A-Z]).*)?$)
        - not:
            propertyConstraints:
              shapes.format:
                minCount: 1
                in:
                  - date-time
        - not:
            propertyConstraints:
              shacl.datatype:
                minCount: 1
                in:
                  - http://www.w3.org/2001/XMLSchema#dateTime
    then:
      or:
        - propertyConstraints:
            shapes.format:
              minCount: 1
              in:
                - date
                - date-only
        - propertyConstraints:
            shacl.datatype:
              minCount: 1
              in:
                - http://www.w3.org/2001/XMLSchema#date
  date-time-representation:
    message: >
      Use the following ISO8601 standard date-time formats for timestaps
      encoding properties:

      - UTC
        - 2016-10-27T13:42:21+00:00 (+00:00 is the time zone offset)
        - 2016-10-27T13:42:21Z (Z is a place holder for local time zone)
    targetClass: shapes.ScalarShape
    if:
      propertyConstraints:
        shacl.name:
          in:
            - createdAt
            - updatedAt
    then:
      propertyConstraints:
        shapes.format:
          minCount: 1
          in:
            - date-time
            - rfc3339
  define-path-params:
    message: Parameters referenced in the path string must be defined
    targetClass: apiContract.Operation
    rego: >
      # obtain the endpoint that contains this operation

      target_class[endpoints_raw] with data.class as "http://a.ml/vocabularies/apiContract#EndPoint"

      endpoints = nodes_array with data.nodes as endpoints_raw

      endpoint := endpoints[_]

      operations_in_endpoint = nodes_array with data.nodes as endpoint["http://a.ml/vocabularies/apiContract#supportedOperation"]

      operation_in_endpoint = operations_in_endpoint[_]

      operation_in_endpoint["@id"] = x["@id"] # endpoint contains this operation


      # retrieve path variables from endpoint

      path = endpoint["http://a.ml/vocabularies/apiContract#path"]

      path_variables = {v | ms = regex.find_all_string_submatch_n("{([a-zA-Z0-9_-]+)}", path, -1); m = ms[_]; v = m[1] }


      # retrieve the uri parameters declared by this endpoint

      endpoint_uri_parameters = {uri_parameter |
        nested_nodes[parameters] with data.nodes as object.get(endpoint, "http://a.ml/vocabularies/apiContract#parameter", [])
        parameter = parameters[_]
        parameter["http://a.ml/vocabularies/apiContract#binding"] = "path"
        uri_parameter = parameter
      }


      # retrieve the uri parameters declared by this operation

      operation_uri_parameters = {uri_parameter |
        nested_nodes[requests] with data.nodes as object.get($node, "http://a.ml/vocabularies/apiContract#expects", [])
        request = requests[_]
        nested_nodes[parameters] with data.nodes as object.get(request, "http://a.ml/vocabularies/apiContract#uriParameter", [])
        parameter = parameters[_]
        parameter["http://a.ml/vocabularies/apiContract#binding"] = "path"
        uri_parameter = parameter
      }


      # filter virtual parameters

      virtual_parameters = { virtual_parameter | 
        parameters = endpoint_uri_parameters | operation_uri_parameters
        parameter = parameters[_]
        source_maps = find with data.link as object.get(parameter, "http://a.ml/vocabularies/document-source-maps#sources", {})
        virtual_element = find with data.link as object.get(source_maps, "http://a.ml/vocabularies/document-source-maps#virtual-element", {})
        virtual_element["http://a.ml/vocabularies/document-source-maps#element"] = parameter["@id"]
        virtual_element["http://a.ml/vocabularies/document-source-maps#value"] = "true"
        virtual_parameter = parameter
      }


      # extract names from all uri parameters

      parameter_names = {name |
        parameters = (endpoint_uri_parameters | operation_uri_parameters) - virtual_parameters
        parameter = parameters[_]
        name = parameter["http://a.ml/vocabularies/core#name"]
      }


      $result = (count(path_variables - parameter_names) == 0)
  define-path-template-variables:
    message: Unused path parameters in path template
    targetClass: apiContract.Operation
    rego: >
      # obtain the endpoint that contains this operation

      target_class[endpoints_raw] with data.class as "http://a.ml/vocabularies/apiContract#EndPoint"

      endpoints = nodes_array with data.nodes as endpoints_raw

      endpoint := endpoints[_]

      operations_in_endpoint = nodes_array with data.nodes as endpoint["http://a.ml/vocabularies/apiContract#supportedOperation"]

      operation_in_endpoint = operations_in_endpoint[_]

      operation_in_endpoint["@id"] = x["@id"] # endpoint contains this operation


      # retrieve path variables from endpoint

      path = endpoint["http://a.ml/vocabularies/apiContract#path"]

      path_variables = {v | ms = regex.find_all_string_submatch_n("{([a-zA-Z0-9_-]+)}", path, -1); m = ms[_]; v = m[1] }


      # retrieve the uri parameters declared by this endpoint

      endpoint_uri_parameters = {uri_parameter |
        nested_nodes[parameters] with data.nodes as object.get(endpoint, "http://a.ml/vocabularies/apiContract#parameter", [])
        parameter = parameters[_]
        parameter["http://a.ml/vocabularies/apiContract#binding"] = "path"
        uri_parameter = parameter
      }


      # retrieve the uri parameters declared by this operation

      operation_uri_parameters = {uri_parameter |
        nested_nodes[requests] with data.nodes as object.get($node, "http://a.ml/vocabularies/apiContract#expects", [])
        request = requests[_]
        nested_nodes[parameters] with data.nodes as object.get(request, "http://a.ml/vocabularies/apiContract#uriParameter", [])
        parameter = parameters[_]
        parameter["http://a.ml/vocabularies/apiContract#binding"] = "path"
        uri_parameter = parameter
      }


      # filter virtual parameters

      virtual_parameters = { virtual_parameter | 
        parameters = endpoint_uri_parameters | operation_uri_parameters
        parameter = parameters[_]
        source_maps = find with data.link as object.get(parameter, "http://a.ml/vocabularies/document-source-maps#sources", {})
        virtual_element = find with data.link as object.get(source_maps, "http://a.ml/vocabularies/document-source-maps#virtual-element", {})
        virtual_element["http://a.ml/vocabularies/document-source-maps#element"] = parameter["@id"]
        virtual_element["http://a.ml/vocabularies/document-source-maps#value"] = "true"
        virtual_parameter = parameter
      }


      # extract names from all uri parameters

      parameter_names = {name |
        parameters = (endpoint_uri_parameters | operation_uri_parameters) - virtual_parameters
        parameter = parameters[_]
        name = parameter["http://a.ml/vocabularies/core#name"]
      }


      $result = (count(parameter_names - path_variables) == 0)
  duplicated-entry-in-enum:
    message: Enum values must be unique.
    targetClass: shapes.ScalarShape
    rego: >
      enum = object.get($node, "http://www.w3.org/ns/shacl#in",[])

      enumValues = find with data.link as enum

      props = [r | d = enumValues[_]; is_object(d); n=find with data.link as d; r=n["http://a.ml/vocabularies/data#value"] ]

      propsSet = {r | v = props[_]; r=v}

      $result = (count(props) == count(propsSet))
  headers-must-have-descriptions:
    message: Provide descriptions for headers.
    targetClass: apiContract.Parameter
    if:
      propertyConstraints:
        apiContract.binding:
          pattern: header
    then:
      propertyConstraints:
        core.description:
          minCount: 1
  heterogeneous-union:
    message: |
      Unions between different types are not a good design practice. Object
      shapes with scalar flags/properties are an acceptable alternative.
    targetClass: shapes.AnyShape
    rego: >
      nested_nodes[members_xone] with data.nodes as
      object.get($node,"http://www.w3.org/ns/shacl#xone",[])

      nested_nodes[members_or] with data.nodes as object.get($node,"http://www.w3.org/ns/shacl#or",[])

      nested_nodes[members_anyof] with data.nodes as object.get($node,"http://a.ml/vocabularies/shapes#anyOf",[])

      members = array.concat(members_xone, array.concat(members_or, members_anyof))

      types := { type |
        member := members[_]
        member_types := member["@type"]
        maybe_type = member_types[_]
        maybe_type != "http://a.ml/vocabularies/shapes#Shape"
        maybe_type != "http://www.w3.org/ns/shacl#Shape"
        maybe_type != "http://a.ml/vocabularies/shapes#AnyShape"
        maybe_type != "http://a.ml/vocabularies/document#DomainElement"
        type = maybe_type
      }

      $result = (count(types) <= 1) # 0 if there is no xone,or,anyof at all
  media-type-headers-response:
    message: |
      For the response: use ‘Content-Type’ header
    targetClass: apiContract.Response
    if:
      not:
        propertyConstraints:
          apiContract.statusCode:
            in:
              - 204
    then:
      propertyConstraints:
        apiContract.header:
          atLeast:
            count: 1
            validation:
              propertyConstraints:
                core.name:
                  in:
                    - Content-Type
                    - content-type
  nil-union-antipattern:
    message: |
      Nullable types might lead to null pointer errors.
      Use the optional properties instead.
    targetClass: shapes.AnyShape
    rego: >
      nested_nodes[members_xone] with data.nodes as
      object.get($node,"http://www.w3.org/ns/shacl#xone",[])

      nested_nodes[members_or] with data.nodes as object.get($node,"http://www.w3.org/ns/shacl#or",[])

      nested_nodes[members_anyof] with data.nodes as object.get($node,"http://a.ml/vocabularies/shapes#anyOf",[])

      members = array.concat(members_xone, array.concat(members_or, members_anyof))

      count(members) == 2

      types := { type |
        member := members[_]
        member_types := member["@type"]
        maybe_type = member_types[_]
        maybe_type != "http://a.ml/vocabularies/shapes#Shape"
        maybe_type != "http://www.w3.org/ns/shacl#Shape"
        maybe_type != "http://a.ml/vocabularies/shapes#AnyShape"
        maybe_type != "http://a.ml/vocabularies/document#DomainElement"
        type = maybe_type
      }

      count(types) > 1

      $result = types["http://a.ml/vocabularies/shapes#NilShape"]
  no-2xx-response:
    message: >
      HTTP resources not returning a 2xx success response do not describe
      normal responses from the API.
    targetClass: apiContract.Operation
    propertyConstraints:
      apiContract.returns:
        atLeast:
          count: 1
          validation:
            propertyConstraints:
              apiContract.statusCode:
                pattern: 2[0-9][0-9]
  no-eval-in-markdown:
    message: >
      This rule protects against cross-site scripting (XSS) attacks that
      could happen when you add description

      documents from third parties and use the parsed content rendered in HTML/JS. If one of those third parties

      does something like inject `eval()` JavaScript statements, it could lead to an XSS attack.
    targetClass: apiContract.WebAPI
    not:
      propertyConstraints:
        core.description:
          pattern: eval\(
  no-script-tags-in-markdown:
    message: >
      This rule protects against a potential exploit, that can occur when you
      add description documents from third parties then

      generate HTML documentation. If one of those third parties does something like inject `<script>` tags, they

      could easily execute arbitrary code on your domain.
    targetClass: apiContract.WebAPI
    not:
      propertyConstraints:
        core.description:
          pattern: <script>
  node-shapes-must-have-descriptions:
    message: Provide descriptions for data shapes.
    targetClass: shacl.NodeShape
    propertyConstraints:
      core.description:
        minCount: 1
  non-scalar-url-parameters:
    message: >
      Encoding complex objects into URL parameters is not a standardized way
      of passing information that cannot be

      automatically processed. Complex information should be passed in the body of the HTTP request.
    targetClass: apiContract.Parameter
    if:
      or:
        - propertyConstraints:
            apiContract.binding:
              pattern: path
        - propertyConstraints:
            apiContract.binding:
              pattern: query
    then:
      or:
        - propertyConstraints:
            shapes.schema / shacl.datatype:
              minCount: 1
        - propertyConstraints:
            shapes.schema / shapes.items / shacl.datatype:
              minCount: 1
  not-anonymous-types:
    message: >
      Instead of inlining the definition of schemas in HTTP responses,

      reference declared types to provide descriptive names for the federated types.
    targetClass: apiContract.Operation
    if:
      propertyConstraints:
        apiContract.method:
          pattern: get
    then:
      propertyConstraints:
        apiContract.returns / apiContract.payload:
          nested:
            if:
              propertyConstraints:
                core.mediaType:
                  pattern: application/json
                shapes.schema:
                  minCount: 1
            then:
              propertyConstraints:
                shapes.schema / sourcemaps.sources / sourcemaps.declared-element:
                  minCount: 1
  open-schemas-ignored:
    message: >
      Open schemas with a set of variable properties cannot be pre-processed
      by clients.

      Define a closed schema with a finite set of properties described statically in the API definition.

      AsyncAPI or OAS API definitions' object schemas are open by default and must be explicitly

      closed using `additionalProperties: false`.
    targetClass: shacl.NodeShape
    not:
      propertyConstraints:
        shacl.closed:
          in:
            - "false"
  operations-must-have-descriptions:
    message: Provide descriptions for the operations.
    targetClass: apiContract.Operation
    propertyConstraints:
      core.description:
        minCount: 1
  operations-must-have-identifiers:
    message: Provide identifiers or display names for the operations.
    targetClass: apiContract.Operation
    propertyConstraints:
      core.name:
        minCount: 1
  path-declarations-must-exist:
    message: Path parameter declarations are required. For example, `/given/{}` is
      invalid.
    targetClass: apiContract.EndPoint
    not:
      propertyConstraints:
        apiContract.path:
          pattern: "{}"
  path-keys-no-trailing-slash:
    message: >
      Keep trailing slashes off of paths, as it can cause some confusion.
      Some web tooling (like mock servers, real

      servers, code generators, application frameworks, etc.) will treat example.com/foo and example.com/foo/ as the

      same thing, but other tooling will not. Avoid any confusion by just documenting them without the slash, and maybe

      some tooling will let people shove a / on there when they're using it or maybe not, but at least the docs are

      suggesting how it should be done properly.
    targetClass: apiContract.EndPoint
    not:
      propertyConstraints:
        apiContract.path:
          pattern: \/$
  path-not-include-query:
    message: "Don't put query string items in the path. They belong in parameters
      with `in: query`."
    targetClass: apiContract.EndPoint
    not:
      propertyConstraints:
        apiContract.path:
          pattern: .*\?.*
  preferred-media-type-representations:
    message: >
      If there is no standard media type and format, use extensible formats
      such as JSON

      (application/json) and XML (application/xml).
    targetClass: apiContract.Payload
    propertyConstraints:
      core.mediaType:
        in:
          - application/json
          - application/xml
  property-shape-ranges-must-have-descriptions:
    message: Provide descriptions for properties.
    targetClass: shacl.PropertyShape
    propertyConstraints:
      shapes.range / core.description:
        minCount: 1
  provide-examples:
    message: Always include examples in requests and responses.
    targetClass: apiContract.Payload
    rego: >
      schema = find with data.link as
      $node["http://a.ml/vocabularies/shapes#schema"]


      nested_nodes[examples] with data.nodes as object.get(schema, "http://a.ml/vocabularies/apiContract#examples", [])


      # schemas declared inline 

      tracked_schema_examples = { element |
        example = examples[_]
        sourcemap = find with data.link as object.get(example, "http://a.ml/vocabularies/document-source-maps#sources", [])
        tracked_element = find with data.link as object.get(sourcemap, "http://a.ml/vocabularies/document-source-maps#tracked-element", [])
        values_contains(tracked_element["http://a.ml/vocabularies/document-source-maps#value"], x["@id"])
        element := example
      }
        
      # schemas located in declarations and referenced, without any sourcemap

      declared_examples = { element |
        example = examples[_]
        not example["http://a.ml/vocabularies/document-source-maps#sources"]
        element := example
      }
        
      # schemas located in declarations and referenced, with sourcemaps but not tracked

      untracked_examples = { element |
        example = examples[_]
        sourcemap = find with data.link as object.get(example, "http://a.ml/vocabularies/document-source-maps#sources", [])
        not sourcemap["http://a.ml/vocabularies/document-source-maps#tracked-element"]
        element := example
      }


      $result := count(tracked_schema_examples | declared_examples | untracked_examples) > 0
  query-params-must-have-descriptions:
    message: Provide descriptions for query params.
    targetClass: apiContract.Parameter
    if:
      propertyConstraints:
        apiContract.binding:
          pattern: query
    then:
      propertyConstraints:
        core.description:
          minCount: 1
  request-response-antipattern:
    message: >
      Resource schemas should describe the information of the exposed
      resource, not a Request/Response RPC message wrapper

      containing the resource and out-of-band information.
    targetClass: shacl.NodeShape
    not:
      or:
        - propertyConstraints:
            shacl.name:
              pattern: .*(r|R)equest.*
        - propertyConstraints:
            shacl.name:
              pattern: .*(r|R)esponse.*
  resource-use-lowercase:
    message: |
      Naming conventions for resources:
      - Use lowercase (example: /accounts)
      - For resources with more than 2 words
          - use lowercase for both words (example: /lineitems) or
          - use kebab-case (aka spinal-case) (example: /line-items)
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.path:
        pattern: ^[a-z1-9\/\{\}-]+$
  responses-must-have-descriptions:
    message: Provide descriptions for the responses.
    targetClass: apiContract.Response
    propertyConstraints:
      core.description:
        minCount: 1
  standard-delete-status-codes:
    message: >
      The following response codes should be used as standard for DELETE
      operations: 200,202,204,400,401,403,404,405,

      406,408,409,410,429,500,502,503,504,509,510,511,550,598,599]. Avoid not defined return codes.
    targetClass: apiContract.Operation
    if:
      propertyConstraints:
        apiContract.method:
          pattern: delete
    then:
      propertyConstraints:
        apiContract.returns / apiContract.statusCode:
          in:
            - "200"
            - "202"
            - "204"
            - "400"
            - "401"
            - "403"
            - "404"
            - "405"
            - "406"
            - "408"
            - "409"
            - "410"
            - "429"
            - "500"
            - "502"
            - "503"
            - "504"
            - "509"
            - "510"
            - "511"
            - "550"
            - "598"
            - "599"
  standard-get-status-codes:
    message: >
      The following response codes should be used as standard for GET
      operations:
      200,204,304,400,401,403,404,405,406,408,410,412,415,429,500,502,503,504,509,510,511,550,598,

      599. Avoid not defined return codes.
    targetClass: apiContract.Operation
    if:
      propertyConstraints:
        apiContract.method:
          pattern: get
    then:
      propertyConstraints:
        apiContract.returns / apiContract.statusCode:
          in:
            - "200"
            - "204"
            - "304"
            - "400"
            - "401"
            - "403"
            - "404"
            - "405"
            - "406"
            - "408"
            - "410"
            - "412"
            - "415"
            - "429"
            - "500"
            - "502"
            - "503"
            - "504"
            - "509"
            - "510"
            - "511"
            - "550"
            - "598"
            - "599"
  standard-post-status-codes:
    message: >
      The following response codes should be used as standard for POST
      operations:

      201,202,400,401,403,404,405,406,408,409,410,415,429,500,502,503,504,509,510,511,550,598,599.

      Avoid not defined return codes.
    targetClass: apiContract.Operation
    if:
      propertyConstraints:
        apiContract.method:
          pattern: post
    then:
      propertyConstraints:
        apiContract.returns / apiContract.statusCode:
          in:
            - "201"
            - "202"
            - "400"
            - "401"
            - "403"
            - "404"
            - "405"
            - "406"
            - "408"
            - "409"
            - "410"
            - "415"
            - "429"
            - "500"
            - "502"
            - "503"
            - "504"
            - "509"
            - "510"
            - "511"
            - "550"
            - "598"
            - "599"
  standard-put-status-codes:
    message: >
      The following response codes should be used as standard for PUT
      operations:

      200,202,204,400,401,403,404,405,406,408,409,410,412,415,429,500,502,503,504,509,510,511,550,

      598,599. Avoid not defined return codes.
    targetClass: apiContract.Operation
    if:
      propertyConstraints:
        apiContract.method:
          pattern: put
    then:
      propertyConstraints:
        apiContract.returns / apiContract.statusCode:
          in:
            - "200"
            - "202"
            - "204"
            - "400"
            - "401"
            - "403"
            - "404"
            - "405"
            - "406"
            - "408"
            - "409"
            - "410"
            - "412"
            - "415"
            - "429"
            - "500"
            - "502"
            - "503"
            - "504"
            - "509"
            - "510"
            - "511"
            - "550"
            - "598"
            - "599"
  unsupported-response-schema-shapes:
    message: >
      This datatype is not supported and will create a problem when adding
      the API to Anypoint DataGraph.
    targetClass: shapes.AnyShape
    not:
      or:
        - propertyConstraints:
            "@type":
              pattern: .*MatrixShape
        - propertyConstraints:
            "@type":
              pattern: .*SchemaShape
        - propertyConstraints:
            "@type":
              pattern: .*FileShape
        - propertyConstraints:
            "@type":
              pattern: .*TupleShape
  use-schemas-requests:
    message: >
      Use schemas or data types in the specification to determine the format
      of the request bodies.
    targetClass: apiContract.Request
    if:
      propertyConstraints:
        apiContract.payload:
          minCount: 1
    then:
      propertyConstraints:
        apiContract.payload / shapes.schema:
          minCount: 1
          nested:
            propertyConstraints:
              "@type":
                containsSome:
                  - http://a.ml/vocabularies/shapes#ArrayShape
                  - http://a.ml/vocabularies/shapes#UnionShape
                  - http://a.ml/vocabularies/shapes#SchemaShape
                  - http://a.ml/vocabularies/shapes#FileShape
                  - http://a.ml/vocabularies/shapes#ScalarShape
                  - http://www.w3.org/ns/shacl#NodeShape
  use-schemas-responses:
    message: >
      Use schemas or data types in the specification to determine the format
      of the response bodies.
    targetClass: apiContract.Response
    if:
      propertyConstraints:
        apiContract.payload:
          minCount: 1
    then:
      propertyConstraints:
        apiContract.payload / shapes.schema:
          minCount: 1
          nested:
            propertyConstraints:
              "@type":
                containsSome:
                  - http://a.ml/vocabularies/shapes#ArrayShape
                  - http://a.ml/vocabularies/shapes#UnionShape
                  - http://a.ml/vocabularies/shapes#SchemaShape
                  - http://a.ml/vocabularies/shapes#FileShape
                  - http://a.ml/vocabularies/shapes#ScalarShape
                  - http://www.w3.org/ns/shacl#NodeShape
